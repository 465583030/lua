
DCLua - Go Lua Compiler and VM:
========================================================================================================================

This is a Lua 5.3 VM and compiler written in [Go](http://golang.org/). This is intended to allow easy embedding into Go
programs, with minimal fuss and bother.

I have been using this VM/compiler as the primary script host in Rubble (a scripted templating system used to generate
data files for the game Dwarf Fortress) for over a year now, so they are fairly well tested. Speaking of tests: No formal
unit tests are provided. Testing was done by running under real-world conditions with Rubble, and in Rubble's built-in
template testing system (it is not appropriate to distribute these tests with this library for obvious reasons).

Most (if not all) of the API functions may cause a panic, but only if things go REALLY wrong. If a function does not
state that it can panic or "raise an error" it will only do so if a critical internal assumption proves to be wrong
(AKA there is a bug in the code somewhere). These errors will have a special prefix prepended onto the error message
stating that this error indicates an internal VM bug. If you ever see such an error I want to know about it ASAP.

The VM itself does not provide any Lua functions, the standard library is provided entirely by other packages. This
means that the standard library never does anything that your own code cannot do (there is no "private API" that is used
by the standard library). 

Anything to do with the OS or file IO is not provided. Such things do not belong in the core libraries of an embedded
scripting language (do you really want scripts to be able to read and write random files without restriction?).

All functions (including most of the internal functions) are documented to one degree or another, most quite well. The
API is designed to be easy to use, and everything was added because I needed it. There are no "bloat" functions added
because I thought they could be useful.


Loading Code:
------------------------------------------------------------------------------------------------------------------------

This VM fully supports binary chunks, so if you want to precompile your script it is possible. To precompile a script
for use with this VM you can either build a copy of `luac` (the reference Lua compiler) or use any other third party Lua
complier provided that it generates code compatible with the reference compiler. There is no separate compiler binary
that you can build, but it wouldn't be hard to write one. Note that the VM does not handle certain instructions in pairs
like the reference Lua VM does, and I don't remember if I made the compiler take advantage of this or not. If I did then
binaries generated by my compiler may not work with the reference VM.

If you want to use a third-party compiler it will need to produce binaries with the following settings:

* 64 *or* 32 bit pointers (C type `size_t`), 64 bit preferred.
* 32 bit integers (C type `int`).
* 64 bit float numbers.
* 64 bit integer numbers.
* Little Endian byte order.

When building the reference compiler on most systems these settings should be the default.

The default compiler provided by this library does not support constant folding, and some special instructions are not
used at all (instead preferring simpler sequences of other instructions). For example TESTSET is never generated, TEST
is used in all cases (largely because it would greatly complicate the compiler if I tried to use TESTSET where possible).
Expressions use a simple "recursive" code generation style, meaning that it wastes registers like crazy in some (rare)
cases.

The compiler provides an implementation of a `continue` keyword, but the keyword definition in the lexer is commented
out. If you want `continue` all you need to do is uncomment the indicated line (near the top of `ast/lexer.go`). There
is also a flag in the VM that *should* make tables use 0 based indexing. This feature has received minimal testing, so
it probably doesn't work properly. If you want to try 0 based indexing just set the variable `TableIndexOffset` to 0.


Missing Stuff:
------------------------------------------------------------------------------------------------------------------------

The following standard functions/variables are not available:

* `collectgarbage` (not possible, VM uses the Go collector)
* `dofile` (violates my security policy)
* `loadfile` (violates my security policy)
* `xpcall` (VM has no concept of a message handler)
* `package.config` (violates my security policy)
* `package.cpath` (VM has no support for native modules)
* `package.loadlib` (VM has no support for native modules)
* `package.path` (violates my security policy)
* `package.searchpath` (violates my security policy)
* `string.gmatch` (No pattern matching support)
* `string.gsub` (No pattern matching support)
* `string.match` (No pattern matching support)
* `string.pack` (too lazy to implement, ask if you need it)
* `string.packsize` (too lazy to implement, ask if you need it)
* `string.unpack` (too lazy to implement, ask if you need it)

* * *

The following standard modules are not available:

* `coroutine` (no coroutine support yet, ask if you need it)
* `utf8` (too lazy to implement it, ask if you need it)
* `io` (violates my security policy)
* `os` (violates my security policy)
* `debug` (violates my security policy, if you really need something from here ask)

Coroutine support is not available. I can implement something based on goroutines fairly easily, but I will only do so
if someone actually needs it and/or if I get really bored...

* * *

In addition to the stuff that is not available at all the following functions are not implemented exactly as the Lua
5.3 specification requires:

* `string.find` does not allow pattern matching yet (the fourth option is effectively always set to `true`).
* Only one searcher is added to `package.searchers`, the one for finding modules in `package.preloaded`.
* `next` is not reentrant for a single table, as it needs to store state information about each table it is used to iterate.
  Starting a new iteration for a particular table invalidates the state information for the previous iteration of
  that table. *Never* use this function for iterating a table unless you absolutely *have* to, use the non-standard
  `getiter` function instead. `getiter` works the way `next` should have, namely it uses a single iterator value that
  stores all required iteration state internally (the way the default `next` works is only possible if your hash table
  is implemented a certain way).

Finally there are a few things that are implemented exactly as the Lua 5.3 specification requires, where the reference
Lua implementation does not follow the specification exactly:

* The `#` (length) operator always returns the exact length of a (table) sequence, not the total length of the array
  portion of the table. See the comment in `table.go` (about halfway down) for more details (including quotes from the
  spec and examples).

* * *

The following *core language* features are not supported:

* Hexadecimal floating point literals are not supported at this time. This "feature" is not supported for two reasons:
  I hate floating point in general (so trying to write a converter is pure torture), and when have you *ever* used 
  hexadecimal floating point literals? Lua is the only language I have ever used that supports them, so they are not
  exactly popular...
* Weak references of any kind are not supported. This is because I use Go's garbage collector, and it does not support
  weak references.
* I do not currently support finalizers. It would probably be possible to support them, but it would be a lot of work
  for a feature that is of limited use (I have only ever needed to use a finalizer once, ironically in this library).
  If you have a compelling reason why you need finalizers I could probably add them...


Errors:
------------------------------------------------------------------------------------------------------------------------

Error messages can be summed up with one word right now: Terrible.

The code that generates the stack traces is very simple and doesn't try very hard to produce accurate results. Many error
messages lack details about the exact problem. Generally it isn't too hard to track the problem down, but I really need
to rework the error handler...


`string` Library
------------------------------------------------------------------------------------------------------------------------

The standard Lua string library is pretty pathetic in my opinion. Many simple operations are not possible without
lots of complicated code and/or regular expressions. Of course this is probably because Lua is written in C, and C
also has a pathetic string library (it doesn't even have an actual string type!).

I added some new string handling functions on top of the default. Some of these are similar to what Lua already has, but
without the regular expression support, others fill critical holes in the default API, and a few are lazy conveniences.

Most of these functions assume strings are UTF-8, be careful.

You will only have these functions if you import the `string` module, see the package example.

* * *

	function string.count(str, sub)

Returns the number of non-overlapping occurrences of `sub` in `str`.

* * *

	function string.hasprefix(str, prefix)

Returns true if `str` starts with `prefix`.

* * *

	function string.hassuffix(str, suffix)

Returns true if `str` ends with `suffix`.

* * *

	function string.join(table, [sep])

Joins all the values in `table` with `sep`. If `sep` is not specified then it defaults to ", "

Yes, I know there is a function in the `table` module that does something similar.

* * *

	function string.replace(str, old, new, [n])

Replaces `n` occurrences of `old` with `new` in `str`.
If `n` < 0 then there is no limit on replacements.

* * *

	function string.split(str, sep, [n])

Split `str` into `n` substrings at ever occurrence of `sep`.

* `n` > 0: at most n substrings; the last substring will be the unsplit remainder
* `n` == 0: the result is an empty table
* `n` < 0: all substrings

* * *

	function string.splitafter(str, sep, [n])

This is exactly like `strings.split`, except `sep` is retained as part of the substrings.

* * *

	function string.title(str)

Convert the first character of every word in `str` to it's title case.

* * *

	function string.trim(str, cut)

Returns `str` with any chars in `cut` removed from it's beginning and end.

* * *

	function string.trimprefix(str, prefix)

Returns `str` with `prefix` removed from it's start. `str` is returned unchanged if it does not start with `prefix`.

* * *

	function string.trimspace(str)

Returns `str` with all whitespace trimmed from it's beginning and end.

* * *

	function string.trimsuffix(str, suffix)

Returns `str` with `suffix` removed from it's end. `str` is returned unchanged if it does not end with `suffix`.

* * *

	function string.unquote(str)

If `str` begins and ends with a quote char (one of `` "'` ``) then it will be unquoted using the rules for the
[Go](golang.org) language. This includes escape sequence expansion.
